// Package generated provides primitives to interact the openapi HTTP API.
//
// This is an autogenerated file, any edits which you make here will be lost!
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// Actor defines component schema for Actor.
type Actor struct {
	Identifier Identifier `json:"identifier"`
}

// Endpoint defines component schema for Endpoint.
type Endpoint struct {
	URL          string     `json:"URL"`
	EndpointType string     `json:"endpointType"`
	Identifier   Identifier `json:"identifier"`
	Status       string     `json:"status"`
	Version      string     `json:"version"`
}

// EndpointOrganization defines component schema for EndpointOrganization.
type EndpointOrganization struct {
	Endpoint     Identifier `json:"endpoint"`
	Organization Identifier `json:"organization"`
	Status       string     `json:"status"`
}

// Identifier defines component schema for Identifier.
type Identifier string

// Organization defines component schema for Organization.
type Organization struct {
	Actors     []Actor    `json:"actors,omitempty"`
	Identifier Identifier `json:"identifier"`
	Name       string     `json:"name"`
	PublicKey  *string    `json:"publicKey,omitempty"`
}

// EndpointsByOrganisationIdParams defines parameters for EndpointsByOrganisationId.
type EndpointsByOrganisationIdParams struct {
	OrgIds []string `json:"orgIds"`
	Type   *string  `json:"type,omitempty"`
}

// OrganizationActorsParams defines parameters for OrganizationActors.
type OrganizationActorsParams struct {
	ActorId string `json:"actorId"`
}

// SearchOrganizationsParams defines parameters for SearchOrganizations.
type SearchOrganizationsParams struct {
	Query string `json:"query"`
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Find endpoints based on organisation identifiers and type of endpoint (optional) (GET /api/endpoints)
	EndpointsByOrganisationId(ctx echo.Context, params EndpointsByOrganisationIdParams) error
	// Get organization bij id (GET /api/organization/{id})
	OrganizationById(ctx echo.Context, id string) error
	// get actors for given organization, the main question that is answered by this api: may the professional represent the organization? (GET /api/organization/{id}/actors)
	OrganizationActors(ctx echo.Context, id string, params OrganizationActorsParams) error
	// Search for organizations (GET /api/organizations)
	SearchOrganizations(ctx echo.Context, params SearchOrganizationsParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// EndpointsByOrganisationId converts echo context to params.
func (w *ServerInterfaceWrapper) EndpointsByOrganisationId(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the
	// context.
	var params EndpointsByOrganisationIdParams
	// ------------- Required query parameter "orgIds" -------------
	if paramValue := ctx.QueryParam("orgIds"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument orgIds is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "orgIds", ctx.QueryParams(), &params.OrgIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter orgIds: %s", err))
	}

	// ------------- Optional query parameter "type" -------------
	if paramValue := ctx.QueryParam("type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.EndpointsByOrganisationId(ctx, params)
	return err
}

// OrganizationById converts echo context to params.
func (w *ServerInterfaceWrapper) OrganizationById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.OrganizationById(ctx, id)
	return err
}

// OrganizationActors converts echo context to params.
func (w *ServerInterfaceWrapper) OrganizationActors(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the
	// context.
	var params OrganizationActorsParams
	// ------------- Required query parameter "actorId" -------------
	if paramValue := ctx.QueryParam("actorId"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument actorId is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "actorId", ctx.QueryParams(), &params.ActorId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter actorId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.OrganizationActors(ctx, id, params)
	return err
}

// SearchOrganizations converts echo context to params.
func (w *ServerInterfaceWrapper) SearchOrganizations(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the
	// context.
	var params SearchOrganizationsParams
	// ------------- Required query parameter "query" -------------
	if paramValue := ctx.QueryParam("query"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument query is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "query", ctx.QueryParams(), &params.Query)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter query: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchOrganizations(ctx, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router runtime.EchoRouter, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/api/endpoints", wrapper.EndpointsByOrganisationId)
	router.GET("/api/organization/:id", wrapper.OrganizationById)
	router.GET("/api/organization/:id/actors", wrapper.OrganizationActors)
	router.GET("/api/organizations", wrapper.SearchOrganizations)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/8xYbW8TORD+KyPfSQcnk6SAVLFSdQIEJaJNq0K/HCDk7E4Sg9c2tjchh/LfT+PNZl+S",
	"NC1wL/nCsn6ZZ2aeeWa231hqcms06uBZ8o35dIa5iI9P02AcPWToUydtkEazhD0Fi84bDWEmAog0eDAa",
	"xjgTagJmAkKDcVOh5V8inuDMOmPRBYnxWpmhDnIiMd79q8MJS9gv/RpGf42hP6x3rlacOfxSSIcZS941",
	"L/mw4uyFzqyROtCNbWvXV2fbLiiTRmwEN8yQnCiEAtSA64sg+ocgdUCnMTDO8KvIrUKWsJDapN8/enjc",
	"G/QGvaPk6OGjxxxmIVif9Pu6CL6nVb+6inEWlpbO+eCknrIVZ9Xa27jQhXd9NayQ0Ul6blxW4yicTsha",
	"Uq0mSWq0x902vy/unPkgQuG3UZbvK6BNgLrIKUciDXKOjLNMejFWmLEPO2DN0fl4Yff+9QLoIh+j69rh",
	"UHjMIBjIpA9STwvpZzDGsEDUUNipExn6Tug6xjucaiWlFa9NEGq4PDKryb2LJum3vDkX1ko93SCsTnkQ",
	"OoPmWb9VMdhg9+3zZjp4/icZ3xN01gG8QUEhHrao2wZ1ihqdTKFOV8mMiXHg0DqkeqDIP3sz4iCm49Rk",
	"yAFD2oNh+M2DUAux9ECVE1yRBsxAUFbg+moEE6OUWWAG4yUIyEwxVgipUUbDvSS5H5MXZrgWixLCkqzN",
	"hSqwCtVUzjHe9163Cvh32JTw2OskebL+Dd7rxtIac5IMyt9xa3Wr9qtViWGSuEmaHB0fP0mSi5MRZsJy",
	"uLg+eYVChVkqHHJ4fjI64/Dm7ckpqgydEjrjcHZy6gxqZTg8H52QnY+pcZn4mOEclbE56vCRVFRFj7aK",
	"ulsLbT4LaixlLwiY+0PkLPvQamNGOCeWP6JoWuQ7VJcStUClHnzWZqGBNkUS0fsONesM/mncdOoMWhgV",
	"we8KhS3GSqavcblt8fLFOaCm3GZQboPPuDyoUxE+b7dA2iP1xOxo15dD8BZTOZHrpkdOXV0+B49uLlP0",
	"IOZCKqpXECG6Swl/4HAqfXCER8kUtY8xK2PHTi/P5o9iTmSIgSD3oToCldGGYCZs0DvqDaIyWdTCSpaw",
	"R9RBSe9EmEUe9IWVm84Z30wx6h7xJ8IfZizZqIZ/tiyp5qs1usuJHAMSw95tDy9K+kB1aRrnGuLhqaV8",
	"KdAtKU691opwGNMMw8bLhQwzKPkN6FNBKk/ZIWvxHlYRjgRumBFJ6mwGVyBfD12tguhOBGcbpjSM7+Jb",
	"u0hWvHvV2x1TBRAg9AEzDjgtfTQOXr4aXu1xJZQ9snZkIpRvedLl8Afa7S1pVHTw4WBA/6RGByxbW8Cv",
	"oW+VkLoeRG8tEpsJcDsEK94JwcVrqKCU6as4MRdKZpuoeF4u5GIJYwTMbYiy8/gA8lodRmY/zWJPYDdF",
	"bAu31KlxDtMAHoVLZyVPoz74Is+FW7KEvZS64QKMBTVDo/cDiS2sS4h7JhoV6j5xTEx9s1dTU17xslab",
	"ytj/JrPV3ppt7ny2PFyqTc63ZrEdA/BWi6xoS8JSs1ZmNxbfz6PsTUxt9ca7s7MZxv0MfXxLoAc5d63L",
	"dmjaqJuMO8XQWoax/AQx1BVxWphvIk+/Hg0OcuhpufUOLBr+JyziN0GKTnw/vTuqHKM3/NkkF9aq9ezQ",
	"/+TN96hze/46pM/nIqQzGqId0tTp48RSztAN4eIgJ6ANpIVzqAOxX5klTabUu3KhMxEQpIf1NwCN9LFC",
	"ypqRNK6EwmnMbiPqtcN1fs6l9wRzQ0CoE3CwsIa6rOd16+WwoM+IKm/rESTeXA4eeWmsU3tTDKXRZpCa",
	"VcLjQJcLqSHakdUfbiQpv1+gKz9uwoxeWJlEMaEz1pkJeh+7QP0ltTUO/3HHOt9f3GVT2/oUvqm635R9",
	"cB3l3UVR/fff0P1bFUO7AfzwuHK7hnCHkaU5XPxjY8o6c0Ra08n4XjatVn8HAAD//yQouQCuFAAA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}

