package pkg

import (
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/base64"
	"errors"
	"github.com/google/uuid"
	"github.com/lestrrat-go/jwx/jwk"
	crypto "github.com/nuts-foundation/nuts-crypto/pkg"
	"github.com/nuts-foundation/nuts-crypto/pkg/cert"
	"github.com/nuts-foundation/nuts-crypto/pkg/storage"
	"github.com/nuts-foundation/nuts-crypto/pkg/types"
	core "github.com/nuts-foundation/nuts-go-core"
	certutil "github.com/nuts-foundation/nuts-registry/pkg/cert"
	"github.com/nuts-foundation/nuts-registry/pkg/events"
	"github.com/nuts-foundation/nuts-registry/pkg/events/domain"
	"github.com/nuts-foundation/nuts-registry/test"
	"github.com/spf13/cobra"
	"github.com/stretchr/testify/assert"
	"io/ioutil"
	"os"
	"path/filepath"
	"sort"
	"testing"
	"time"
)

const vendorId = "urn:oid:1.3.6.1.4.1.54851.4:4"

func TestRegistryAdministration_RegisterEndpoint(t *testing.T) {
	var payload = domain.RegisterEndpointEvent{}
	t.Run("ok", func(t *testing.T) {
		cxt := createTestContext(t)
		defer cxt.close()
		cxt.registry.EventSystem.RegisterEventHandler(domain.RegisterEndpoint, func(e events.Event, _ events.EventLookup) error {
			return e.Unmarshal(&payload)
		})
		cxt.registry.RegisterVendor("vendor", domain.HealthcareDomain)
		cxt.registry.VendorClaim("orgId", "org", nil)
		event, err := cxt.registry.RegisterEndpoint("orgId", "endpointId", "url", "type", "status", map[string]string{"foo": "bar"})
		if !assert.NoError(t, err) {
			return
		}
		assert.NotNil(t, event.Signature())
		assert.Equal(t, "orgId", string(payload.Organization))
		assert.Equal(t, "endpointId", string(payload.Identifier))
		assert.Equal(t, "url", payload.URL)
		assert.Equal(t, "type", payload.EndpointType)
		assert.Equal(t, "status", payload.Status)
		assert.Len(t, payload.Properties, 1)
	})
	t.Run("ok - update", func(t *testing.T) {
		cxt := createTestContext(t)
		defer cxt.close()
		cxt.registry.EventSystem.RegisterEventHandler(domain.RegisterEndpoint, func(e events.Event, _ events.EventLookup) error {
			return e.Unmarshal(&payload)
		})
		cxt.registry.RegisterVendor("vendor", domain.HealthcareDomain)
		cxt.registry.VendorClaim("orgId", "org", nil)
		cxt.registry.RegisterEndpoint("orgId", "endpointId", "url", "type", "status", map[string]string{"foo": "bar"})
		// Now update endpoint
		event, err := cxt.registry.RegisterEndpoint("orgId", "endpointId", "url-updated", "type-updated", "status-updated", map[string]string{"foo": "bar-updated"})
		if !assert.NoError(t, err) {
			return
		}
		assert.NotNil(t, event)
		assert.False(t, event.PreviousRef().IsZero())
		assert.Equal(t, "orgId", string(payload.Organization))
		assert.Equal(t, "endpointId", string(payload.Identifier))
		assert.Equal(t, "url-updated", payload.URL)
		assert.Equal(t, "type-updated", payload.EndpointType)
		assert.Equal(t, "status-updated", payload.Status)
		assert.Len(t, payload.Properties, 1)
	})
	t.Run("ok - auto generate id", func(t *testing.T) {
		cxt := createTestContext(t)
		defer cxt.close()
		cxt.registry.EventSystem.RegisterEventHandler(domain.RegisterEndpoint, func(e events.Event, _ events.EventLookup) error {
			return e.Unmarshal(&payload)
		})
		cxt.registry.RegisterVendor("vendor", domain.HealthcareDomain)
		cxt.registry.VendorClaim("orgId", "org", nil)
		event, err := cxt.registry.RegisterEndpoint("orgId", "", "url", "type", "status", map[string]string{"foo": "bar"})
		if !assert.NoError(t, err) {
			return
		}
		assert.NotNil(t, event.Signature())
		assert.Len(t, payload.Identifier, 36) // 36 = length of UUIDv4 as string
	})
	t.Run("ok - org has no certificates", func(t *testing.T) {
		cxt := createTestContext(t)
		defer cxt.close()
		cxt.registry.EventSystem.RegisterEventHandler(domain.RegisterEndpoint, func(e events.Event, _ events.EventLookup) error {
			return e.Unmarshal(&payload)
		})
		cxt.registry.EventSystem.ProcessEvent(events.CreateEvent(domain.RegisterVendor, domain.RegisterVendorEvent{
			Identifier: vendorId,
			Name:       "Test Vendor",
		}, nil))
		cxt.registry.VendorClaim("orgId", "org", nil)
		event, err := cxt.registry.RegisterEndpoint("orgId", "", "url", "type", "status", map[string]string{"foo": "bar"})
		if !assert.NoError(t, err) {
			return
		}
		assert.Nil(t, event.Signature())
	})
	t.Run("error - org not found", func(t *testing.T) {
		cxt := createTestContext(t)
		defer cxt.close()
		endpoint, err := cxt.registry.RegisterEndpoint("orgId", "", "url", "type", "status", map[string]string{"foo": "bar"})
		assert.Nil(t, endpoint)
		assert.Error(t, err)
	})
}

func TestRegistryAdministration_VendorClaim(t *testing.T) {
	var payload = domain.VendorClaimEvent{}
	registerEventHandler := func(registry *Registry) {
		registry.EventSystem.RegisterEventHandler(domain.VendorClaim, func(e events.Event, _ events.EventLookup) error {
			return e.Unmarshal(&payload)
		})
	}

	t.Run("ok - keys generated by crypto", func(t *testing.T) {
		cxt := createTestContext(t)
		defer cxt.close()
		_, err := cxt.registry.RegisterVendor("Test Vendor", domain.HealthcareDomain)
		if err != nil {
			panic(err)
		}
		registerEventHandler(cxt.registry)

		event, err := cxt.registry.VendorClaim(t.Name(), "orgName", nil)
		if !assert.NoError(t, err) {
			return
		}
		assert.NotNil(t, event.Signature())
		assert.Equal(t, vendorId, string(payload.VendorIdentifier))
		assert.Equal(t, t.Name(), string(payload.OrgIdentifier))
		assert.Equal(t, "orgName", payload.OrgName)
		if !assert.Len(t, payload.OrgKeys, 1) {
			return
		}
		jwk, err := cert.MapToJwk(payload.OrgKeys[0].(map[string]interface{}))
		if !assert.NoError(t, err) {
			return
		}
		assert.False(t, payload.Start.IsZero())
		assert.Nil(t, payload.End)
		// Check certificate
		chainInterf, _ := jwk.Get("x5c")
		chain := chainInterf.([]*x509.Certificate)
		if !assert.Len(t, chain, 1) {
			return
		}
		assert.Equal(t, "CN=orgName,O=Test Vendor,C=NL", chain[0].Subject.String())
		assert.Equal(t, "CN=Test Vendor CA Intermediate,O=Test Vendor,C=NL", chain[0].Issuer.String())
		assert.Equal(t, x509.KeyUsageDigitalSignature, chain[0].KeyUsage&x509.KeyUsageDigitalSignature)
		assert.Equal(t, x509.KeyUsageKeyEncipherment, chain[0].KeyUsage&x509.KeyUsageKeyEncipherment)
		assert.Equal(t, x509.KeyUsageDataEncipherment, chain[0].KeyUsage&x509.KeyUsageDataEncipherment)
	})
	t.Run("ok - existing org keys in crypto", func(t *testing.T) {
		cxt := createTestContext(t)
		defer cxt.close()
		vendor, _ := cxt.registry.RegisterVendor("Test Vendor", domain.HealthcareDomain)
		registerVendorEvent := domain.RegisterVendorEvent{}
		vendor.Unmarshal(&registerVendorEvent)
		vendorCertChain, _ := cert.MapToX509CertChain(registerVendorEvent.Keys[0].(map[string]interface{}))
		privKey, _ := cxt.registry.crypto.GetPrivateKey(types.KeyForEntity(types.LegalEntity{URI: vendorId}))

		orgName := t.Name()
		org := types.LegalEntity{URI: uuid.New().String()}
		orgKey := types.KeyForEntity(types.LegalEntity{URI: uuid.New().String()})
		// "Out-of-Band" generate key material
		pubKey, err := cxt.registry.crypto.GenerateKeyPair(orgKey)
		if !assert.NoError(t, err) {
			return
		}
		// Now "Out-of-Band"-sign a certificate with it using the vendor priv. key
		csr, _ := certutil.OrganisationCertificateRequest("Test Vendor", org.URI, orgName, "healthcare")
		csr.PublicKey = pubKey
		certificate := test.SignCertificateFromCSRWithKey(csr, time.Now(), 2, vendorCertChain[0], privKey)
		// Feed it to VendorClaim()
		jwkAsMap, _ := certToJwkMap(certificate, certutil.OrganisationCertificate)
		jwkAsMap[jwk.X509CertChainKey] = base64.StdEncoding.EncodeToString(certificate.Raw)
		event, err := cxt.registry.VendorClaim(org.URI, orgName, []interface{}{jwkAsMap})
		if !assert.NoError(t, err) {
			return
		}
		assert.NotNil(t, event.Signature())
	})

	t.Run("ok - vendor has no active certificates", func(t *testing.T) {
		cxt := createTestContext(t)
		defer cxt.close()
		cxt.registry.EventSystem.ProcessEvent(events.CreateEvent(domain.RegisterVendor, domain.RegisterVendorEvent{
			Identifier: vendorId,
			Name:       "Test Vendor",
		}, nil))
		org := types.LegalEntity{URI: t.Name()}
		event, err := cxt.registry.VendorClaim(org.URI, "orgName", nil)
		assert.NoError(t, err)
		assert.NoError(t, event.Unmarshal(&payload))
		assert.Len(t, payload.OrgKeys, 1)
		// No certificate means no signature
		assert.Nil(t, event.Signature())
		// A certificate couldn't have been issued
		certChain, err := cert.MapToX509CertChain(payload.OrgKeys[0].(map[string]interface{}))
		assert.NoError(t, err)
		assert.Nil(t, certChain)
	})

	t.Run("error - vendor not found", func(t *testing.T) {
		cxt := createTestContext(t)
		defer cxt.close()
		_, err := cxt.registry.VendorClaim(t.Name(), "orgName", nil)
		assert.Contains(t, err.Error(), "vendor not found")
	})

	t.Run("error - vendor has no keys", func(t *testing.T) {
		cxt := createTestContext(t)
		defer cxt.close()
		cxt.registry.RegisterVendor("Test Vendor Without Certificate", domain.HealthcareDomain)
		cxt.empty()
		_, err := cxt.registry.VendorClaim("org", "orgName", nil)
		assert.Contains(t, err.Error(), crypto.ErrUnknownCA.Error())
		assert.Contains(t, err.Error(), ErrCertificateIssue.Error())
	})

	t.Run("error - while generating key", func(t *testing.T) {
		cxt := createTestContext(t)
		defer cxt.close()
		c := cxt.registry.crypto.(*crypto.Crypto)
		var defaultKeySize = c.Config.Keysize
		c.Config.Keysize = -1
		defer func() {
			c.Config.Keysize = defaultKeySize
		}()
		_, err := cxt.registry.VendorClaim("org", "orgName", nil)
		assert.Error(t, err)
	})

	t.Run("error - unable to load existing key", func(t *testing.T) {
		cxt := createTestContext(t)
		defer cxt.close()
		cxt.registry.RegisterVendor("Test Vendor", domain.HealthcareDomain)
		entity := types.LegalEntity{URI: "org"}
		_, err := cxt.registry.crypto.GenerateKeyPair(types.KeyForEntity(entity))
		if !assert.NoError(t, err) {
			return
		}
		f := getLastUpdatedFile(filepath.Join(cxt.repo.Directory, "keys"))
		ioutil.WriteFile(f, []byte("this is not a private key"), os.ModePerm)
		_, err = cxt.registry.VendorClaim(entity.URI, "orgName", nil)
		assert.EqualError(t, err, "malformed PEM block")
	})
}

func TestRegistryAdministration_RegisterVendor(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		cxt := createTestContext(t)
		defer cxt.close()
		var registerVendorEvent *domain.RegisterVendorEvent
		cxt.registry.EventSystem.RegisterEventHandler(domain.RegisterVendor, func(event events.Event, _ events.EventLookup) error {
			e := domain.RegisterVendorEvent{}
			if err := event.Unmarshal(&e); err != nil {
				return err
			}
			registerVendorEvent = &e
			return nil
		})

		event, err := cxt.registry.RegisterVendor("Foobar Software", "healthcare")
		if !assert.NoError(t, err) {
			return
		}
		// Verify RegisterVendor event emitted
		if !assert.NotNil(t, registerVendorEvent) {
			return
		}
		assert.NotNil(t, event)
		// Verify CA Certificate issued
		key, err := cert.MapToJwk(registerVendorEvent.Keys[0].(map[string]interface{}))
		if err != nil {
			panic(err)
		}
		certType, _ := key.Get("ct")
		assert.Equal(t, string(certutil.VendorCACertificate), certType)
		chain := key.X509CertChain()
		if !assert.NotNil(t, chain) {
			return
		}
		if !assert.Len(t, chain, 1) {
			return
		}
		assert.Equal(t, "Foobar Software CA Intermediate", chain[0].Subject.CommonName)
	})
	t.Run("error - unable to publish event", func(t *testing.T) {
		cxt := createTestContext(t)
		defer cxt.close()
		cxt.registry.EventSystem.RegisterEventHandler(domain.RegisterVendor, func(event events.Event, _ events.EventLookup) error {
			return errors.New("unit test error")
		})
		_, err := cxt.registry.RegisterVendor("Foobar Software", "healthcare")
		assert.Contains(t, err.Error(), "unit test error")
	})
}

func TestRegistryAdministration_RefreshVendorCertificate(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		cxt := createTestContext(t)
		defer cxt.close()
		cxt.registry.RegisterVendor("Test Vendor", domain.HealthcareDomain)
		event, err := cxt.registry.RefreshVendorCertificate()
		if !assert.NoError(t, err) {
			return
		}
		assert.NotNil(t, event.Signature())
		vendor := cxt.registry.Db.VendorByID(vendorId)
		assert.Len(t, vendor.Keys, 2)
	})
	t.Run("error - vendor not found", func(t *testing.T) {
		cxt := createTestContext(t)
		defer cxt.close()
		event, err := cxt.registry.RefreshVendorCertificate()
		assert.Nil(t, event)
		assert.EqualError(t, err, "vendor doesn't exist (id=urn:oid:1.3.6.1.4.1.54851.4:4)")
	})
}

func TestRegistryAdministration_RefreshOrganizationCertificate(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		cxt := createTestContext(t)
		defer cxt.close()
		cxt.registry.RegisterVendor("Test Vendor", domain.HealthcareDomain)
		cxt.registry.VendorClaim("123", "Test Org", nil)
		event, err := cxt.registry.RefreshOrganizationCertificate("123")
		if !assert.NoError(t, err) {
			return
		}
		assert.NotNil(t, event.Signature())
		org, _ := cxt.registry.Db.OrganizationById("123")
		assert.Len(t, org.Keys, 2)
	})
	t.Run("error - vendor not found", func(t *testing.T) {
		cxt := createTestContext(t)
		defer cxt.close()
		event, err := cxt.registry.RefreshOrganizationCertificate("123")
		assert.Nil(t, event)
		assert.EqualError(t, err, "vendor not found (id=urn:oid:1.3.6.1.4.1.54851.4:4)")
	})
	t.Run("error - organization not found", func(t *testing.T) {
		cxt := createTestContext(t)
		defer cxt.close()
		cxt.registry.RegisterVendor("Test Vendor", domain.HealthcareDomain)
		event, err := cxt.registry.RefreshOrganizationCertificate("123")
		assert.Nil(t, event)
		assert.EqualError(t, err, "organization not found")
	})
}

func TestCreateAndSubmitCSR(t *testing.T) {
	entity := types.LegalEntity{URI: "foo"}

	t.Run("ok", func(t *testing.T) {
		cxt := createTestContext(t)
		defer cxt.close()
		cxt.registry.crypto.GenerateKeyPair(types.KeyForEntity(entity))
		_, err := cxt.registry.createAndSubmitCSR(func() (x509.CertificateRequest, error) {
			return x509.CertificateRequest{Subject: pkix.Name{CommonName: "Mosselman"}}, nil
		}, entity, entity, crypto.CertificateProfile{})
		assert.NoError(t, err)
	})
	t.Run("error - csr template fn error", func(t *testing.T) {
		cxt := createTestContext(t)
		defer cxt.close()
		_, err := cxt.registry.createAndSubmitCSR(func() (x509.CertificateRequest, error) {
			return x509.CertificateRequest{}, errors.New("oops")
		}, entity, entity, crypto.CertificateProfile{})
		assert.Contains(t, err.Error(), "unable to create CSR template")
	})
	t.Run("error - key pair unavailable", func(t *testing.T) {
		cxt := createTestContext(t)
		defer cxt.close()
		unknownEntity := types.LegalEntity{URI: "unknown"}
		_, err := cxt.registry.createAndSubmitCSR(func() (x509.CertificateRequest, error) {
			return x509.CertificateRequest{Subject: pkix.Name{CommonName: "Mosselman"}}, nil
		}, unknownEntity, unknownEntity, crypto.CertificateProfile{})
		assert.Contains(t, err.Error(), "unable to retrieve subject private key")
	})
}

func TestRegistry_signAsVendor(t *testing.T) {
	t.Run("error - unable to create CSR", func(t *testing.T) {
		cxt := createTestContext(t)
		defer cxt.close()
		_, err := cxt.registry.signAsVendor(vendorId, "vendorName", "", []byte{1, 2, 3}, time.Now())
		assert.Equal(t, err.Error(), "unable to create CSR for JWS signing: missing domain")
	})
}

func TestRegistry_signAsOrganization(t *testing.T) {
	t.Run("error - unable to create CSR", func(t *testing.T) {
		cxt := createTestContext(t)
		defer cxt.close()
		err := cxt.registry.EventSystem.ProcessEvent(events.CreateEvent(domain.RegisterVendor, domain.RegisterVendorEvent{Identifier: vendorId, Name: "Vendor"}, nil))
		if !assert.NoError(t, err) {
			return
		}
		_, err = cxt.registry.signAsOrganization("orgId", "", []byte{1, 2, 3}, time.Now(), true)
		assert.Equal(t, "unable to create CSR for JWS signing: missing organization name", err.Error())
	})
	t.Run("error - unable to sign JWS (CA key material missing)", func(t *testing.T) {
		cxt := createTestContext(t)
		defer cxt.close()
		err := cxt.registry.EventSystem.ProcessEvent(events.CreateEvent(domain.RegisterVendor, domain.RegisterVendorEvent{Identifier: vendorId, Name: "Vendor"}, nil))
		if !assert.NoError(t, err) {
			return
		}
		_, err = cxt.registry.signAsOrganization("orgId", "Foobar", nil, time.Now(), true)
		assert.Contains(t, err.Error(), "unable to sign JWS: unknown CA")
	})
	t.Run("error - vendor not found", func(t *testing.T) {
		cxt := createTestContext(t)
		defer cxt.close()
		_, err := cxt.registry.signAsOrganization("orgId", "Foobar", nil, time.Now(), true)
		assert.Contains(t, err.Error(), "vendor not found (id=urn:oid:1.3.6.1.4.1.54851.4:4)")
	})
}

func TestRegistry_signAndPublishEvent(t *testing.T) {
	t.Run("error - signer returns error", func(t *testing.T) {
		cxt := createTestContext(t)
		defer cxt.close()
		event, err := cxt.registry.signAndPublishEvent(domain.RegisterVendor, domain.RegisterVendorEvent{}, nil, func([]byte, time.Time) ([]byte, error) {
			return nil, errors.New("error")
		})
		assert.Nil(t, event)
		assert.Error(t, err, "error")
	})
}

func getLastUpdatedFile(dir string) string {
	entries, _ := ioutil.ReadDir(dir)
	sort.Slice(entries, func(i, j int) bool {
		return entries[i].ModTime().After(entries[j].ModTime())
	})
	return filepath.Join(dir, entries[0].Name())
}

func createRegistry(repo *test.TestRepo) *Registry {
	core.NutsConfig().Load(&cobra.Command{})
	registry := Registry{
		Config: DefaultRegistryConfig(),
		EventSystem: events.NewEventSystem(domain.GetEventTypes()...),
	}
	registry.Config.Datadir = repo.Directory
	err := registry.Configure()
	if err != nil {
		panic(err)
	}
	cryptoBackend, _ := storage.NewFileSystemBackend(filepath.Join(repo.Directory, "keys"))
	registry.crypto = &crypto.Crypto{
		Storage: cryptoBackend,
		Config: crypto.CryptoConfig{
			Keysize: 2048,
		},
	}
	return &registry
}

type testContext struct {
	registry *Registry
	repo     *test.TestRepo
}

func (cxt *testContext) empty() {
	cxt.repo.Cleanup()
	os.MkdirAll(filepath.Join(cxt.repo.Directory, "keys"), os.ModePerm)
	os.MkdirAll(filepath.Join(cxt.repo.Directory, "events"), os.ModePerm)
}

func (cxt *testContext) close() {
	defer os.Unsetenv("NUTS_IDENTITY")
	defer cxt.registry.Shutdown()
	defer cxt.repo.Cleanup()
}

func createTestContext(t *testing.T) testContext {
	os.Setenv("NUTS_IDENTITY", vendorId)
	repo, err := test.NewTestRepo(t.Name())
	if err != nil {
		panic(err)
	}
	context := testContext{
		registry: createRegistry(repo),
		repo:     repo,
	}
	return context
}
