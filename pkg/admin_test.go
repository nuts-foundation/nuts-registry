package pkg

import (
	"crypto/x509"
	"crypto/x509/pkix"
	"errors"
	crypto "github.com/nuts-foundation/nuts-crypto/pkg"
	"github.com/nuts-foundation/nuts-crypto/pkg/storage"
	"github.com/nuts-foundation/nuts-crypto/pkg/types"
	core "github.com/nuts-foundation/nuts-go-core"
	"github.com/nuts-foundation/nuts-registry/pkg/cert"
	"github.com/nuts-foundation/nuts-registry/pkg/events"
	"github.com/nuts-foundation/nuts-registry/test"
	"github.com/spf13/cobra"
	"github.com/stretchr/testify/assert"
	"io/ioutil"
	"os"
	"path/filepath"
	"sort"
	"testing"
)

func TestRegistryAdministration_RegisterEndpoint(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		cxt := createTestContext(t)
		defer cxt.close()
		var event = events.RegisterEndpointEvent{}
		cxt.registry.EventSystem.RegisterEventHandler(events.RegisterEndpoint, func(e events.Event) error {
			return e.Unmarshal(&event)
		})

		_, err := cxt.registry.RegisterEndpoint("orgId", "endpointId", "url", "type", "status", map[string]string{"foo": "bar"})
		if !assert.NoError(t, err) {
			return
		}
		assert.Equal(t, "orgId", string(event.Organization))
		assert.Equal(t, "endpointId", string(event.Identifier))
		assert.Equal(t, "url", event.URL)
		assert.Equal(t, "type", event.EndpointType)
		assert.Equal(t, "status", event.Status)
		assert.Len(t, event.Properties, 1)
	})
	t.Run("ok - auto generate id", func(t *testing.T) {
		cxt := createTestContext(t)
		defer cxt.close()
		var event = events.RegisterEndpointEvent{}
		cxt.registry.EventSystem.RegisterEventHandler(events.RegisterEndpoint, func(e events.Event) error {
			return e.Unmarshal(&event)
		})
		_, err := cxt.registry.RegisterEndpoint("orgId", "", "url", "type", "status", map[string]string{"foo": "bar"})
		if !assert.NoError(t, err) {
			return
		}
		assert.Len(t, event.Identifier, 36) // 36 = length of UUIDv4 as string
	})
}

func TestRegistryAdministration_VendorClaim(t *testing.T) {
	var event = events.VendorClaimEvent{}
	registerEventHandler := func(registry *Registry) {
		registry.Db.RegisterEventHandlers(registry.EventSystem)
		registry.EventSystem.RegisterEventHandler(events.VendorClaim, func(e events.Event) error {
			return e.Unmarshal(&event)
		})
	}

	t.Run("ok - keys generated by crypto", func(t *testing.T) {
		cxt := createTestContext(t)
		defer cxt.close()
		_, err := cxt.registry.RegisterVendor("vendorId", "Test Vendor", "")
		if err != nil {
			panic(err)
		}
		registerEventHandler(cxt.registry)

		_, err = cxt.registry.VendorClaim("vendorId", t.Name(), "orgName", nil)
		if !assert.NoError(t, err) {
			return
		}
		assert.Equal(t, "vendorId", string(event.VendorIdentifier))
		assert.Equal(t, t.Name(), string(event.OrgIdentifier))
		assert.Equal(t, "orgName", event.OrgName)
		if !assert.Len(t, event.OrgKeys, 1) {
			return
		}
		jwk, err := crypto.MapToJwk(event.OrgKeys[0].(map[string]interface{}))
		if !assert.NoError(t, err) {
			return
		}
		assert.False(t, event.Start.IsZero())
		assert.Nil(t, event.End)
		// Check certificate
		chainInterf, _ := jwk.Get("x5c")
		chain := chainInterf.([]*x509.Certificate)
		if !assert.Len(t, chain, 1) {
			return
		}
		assert.Equal(t, "CN=orgName,O=Test Vendor,C=NL", chain[0].Subject.String())
		assert.Equal(t, "CN=Test Vendor CA,O=Test Vendor,C=NL", chain[0].Issuer.String())
		assert.Equal(t, x509.KeyUsageDigitalSignature, chain[0].KeyUsage&x509.KeyUsageDigitalSignature)
		assert.Equal(t, x509.KeyUsageKeyEncipherment, chain[0].KeyUsage&x509.KeyUsageKeyEncipherment)
		assert.Equal(t, x509.KeyUsageDataEncipherment, chain[0].KeyUsage&x509.KeyUsageDataEncipherment)
	})
	t.Run("ok - org keys loaded from crypto", func(t *testing.T) {
		cxt := createTestContext(t)
		defer cxt.close()
		cxt.registry.RegisterVendor("vendorId", "Test Vendor", "")

		org := types.LegalEntity{URI: t.Name()}
		err := cxt.registry.crypto.GenerateKeyPairFor(org)
		key, _ := cxt.registry.crypto.PublicKeyInJWK(org)
		if !assert.NoError(t, err) {
			return
		}
		jwkAsMap, _ := crypto.JwkToMap(key)
		_, err = cxt.registry.VendorClaim("vendorId", org.URI, "orgName", []interface{}{jwkAsMap})
		if !assert.NoError(t, err) {
			return
		}
	})

	t.Run("error - vendor has no active certificates", func(t *testing.T) {
		cxt := createTestContext(t)
		defer cxt.close()
		cxt.registry.EventSystem.ProcessEvent(events.CreateEvent(events.RegisterVendor, events.RegisterVendorEvent{
			Identifier: "vendorId",
			Name:       "Test Vendor",
		}))
		org := types.LegalEntity{URI: t.Name()}
		_, err := cxt.registry.VendorClaim("vendorId", org.URI, "orgName", nil)
		assert.Equal(t, err.Error(), "vendor has no active certificates (id = vendorId)")
	})

	t.Run("error - vendor not found", func(t *testing.T) {
		cxt := createTestContext(t)
		defer cxt.close()
		_, err := cxt.registry.VendorClaim("vendorId2", t.Name(), "orgName", nil)
		assert.Contains(t, err.Error(), "vendor not found")
	})

	t.Run("error - vendor has no keys", func(t *testing.T) {
		cxt := createTestContext(t)
		defer cxt.close()
		cxt.registry.RegisterVendor("vendorWithoutCertificate", "Test Vendor Without Certificate", "")
		cxt.empty()
		_, err := cxt.registry.VendorClaim("vendorWithoutCertificate", "org", "orgName", nil)
		assert.Contains(t, err.Error(), crypto.ErrUnknownCA.Error())
		assert.Contains(t, err.Error(), ErrCertificateIssue.Error())
	})

	t.Run("error - while generating key", func(t *testing.T) {
		cxt := createTestContext(t)
		defer cxt.close()
		c := cxt.registry.crypto.(*crypto.Crypto)
		var defaultKeySize = c.Config.Keysize
		c.Config.Keysize = -1
		defer func() {
			c.Config.Keysize = defaultKeySize
		}()
		_, err := cxt.registry.VendorClaim("vendorId", "org", "orgName", nil)
		assert.Error(t, err)
	})

	t.Run("error - unable to load existing key", func(t *testing.T) {
		cxt := createTestContext(t)
		defer cxt.close()
		cxt.registry.RegisterVendor("vendorID", "Test Vendor", "")
		entity := types.LegalEntity{URI: "org"}
		err := cxt.registry.crypto.GenerateKeyPairFor(entity)
		if !assert.NoError(t, err) {
			return
		}
		f := getLastUpdatedFile(filepath.Join(cxt.repo.Directory, "keys"))
		ioutil.WriteFile(f, []byte("this is not a private key"), os.ModePerm)
		_, err = cxt.registry.VendorClaim("vendorID", entity.URI, "orgName", nil)
		assert.EqualError(t, err, "malformed PEM block")
	})
}

func TestRegistryAdministration_RegisterVendor(t *testing.T) {
	t.Run("ok", func(t *testing.T) {
		cxt := createTestContext(t)
		defer cxt.close()
		var registerVendorEvent *events.RegisterVendorEvent
		cxt.registry.EventSystem.RegisterEventHandler(events.RegisterVendor, func(event events.Event) error {
			e := events.RegisterVendorEvent{}
			if err := event.Unmarshal(&e); err != nil {
				return err
			}
			registerVendorEvent = &e
			return nil
		})

		event, err := cxt.registry.RegisterVendor("foobar", "Foobar Software", "healthcare")
		if !assert.NoError(t, err) {
			return
		}
		// Verify RegisterVendor event emitted
		if !assert.NotNil(t, registerVendorEvent) {
			return
		}
		assert.NotNil(t, event)
		// Verify CA Certificate issued
		key, err := crypto.MapToJwk(registerVendorEvent.Keys[0].(map[string]interface{}))
		if err != nil {
			panic(err)
		}
		certType, _ := key.Get("ct")
		assert.Equal(t, string(cert.VendorCACertificate), certType)
		chain := key.X509CertChain()
		if !assert.NotNil(t, chain) {
			return
		}
		if !assert.Len(t, chain, 1) {
			return
		}
		assert.Equal(t, "Foobar Software CA", chain[0].Subject.CommonName)
	})
	t.Run("error - unable to publish event", func(t *testing.T) {
		cxt := createTestContext(t)
		defer cxt.close()
		cxt.registry.EventSystem.RegisterEventHandler(events.RegisterVendor, func(event events.Event) error {
			return errors.New("unit test error")
		})
		_, err := cxt.registry.RegisterVendor("foobar", "Foobar Software", "healthcare")
		assert.Contains(t, err.Error(), "unit test error")
	})
}

func TestCreateAndSubmitCSR(t *testing.T) {
	entity := types.LegalEntity{URI: "foo"}

	t.Run("ok", func(t *testing.T) {
		cxt := createTestContext(t)
		defer cxt.close()
		cxt.registry.crypto.GenerateKeyPairFor(entity)
		_, err := cxt.registry.createAndSubmitCSR(func() (x509.CertificateRequest, error) {
			return x509.CertificateRequest{Subject: pkix.Name{CommonName: "Mosselman"}}, nil
		}, entity, entity, crypto.CertificateProfile{})
		assert.NoError(t, err)
	})
	t.Run("error - csr template fn error", func(t *testing.T) {
		cxt := createTestContext(t)
		defer cxt.close()
		_, err := cxt.registry.createAndSubmitCSR(func() (x509.CertificateRequest, error) {
			return x509.CertificateRequest{}, errors.New("oops")
		}, entity, entity, crypto.CertificateProfile{})
		assert.Contains(t, err.Error(), "unable to create CSR template")
	})
	t.Run("error - key pair unavailable", func(t *testing.T) {
		cxt := createTestContext(t)
		defer cxt.close()
		unknownEntity := types.LegalEntity{URI: "unknown"}
		_, err := cxt.registry.createAndSubmitCSR(func() (x509.CertificateRequest, error) {
			return x509.CertificateRequest{Subject: pkix.Name{CommonName: "Mosselman"}}, nil
		}, unknownEntity, unknownEntity, crypto.CertificateProfile{})
		assert.Contains(t, err.Error(), "unable to retrieve subject private key")
	})
}

func getLastUpdatedFile(dir string) string {
	entries, _ := ioutil.ReadDir(dir)
	sort.Slice(entries, func(i, j int) bool {
		return entries[i].ModTime().After(entries[j].ModTime())
	})
	return filepath.Join(dir, entries[0].Name())
}

func createRegistry(repo *test.TestRepo) *Registry {
	os.Setenv("NUTS_IDENTITY", "urn:oid:1.3.6.1.4.1.54851.4:4")
	defer os.Unsetenv("NUTS_IDENTITY")
	core.NutsConfig().Load(&cobra.Command{})
	registry := Registry{
		Config: RegistryConfig{
			Mode:                            core.ServerEngineMode,
			Datadir:                         repo.Directory,
			SyncMode:                        "fs",
			OrganisationCertificateValidity: 365,
		},
		EventSystem: events.NewEventSystem(),
	}
	err := registry.Configure()
	cryptoBackend, _ := storage.NewFileSystemBackend(filepath.Join(repo.Directory, "keys"))
	registry.crypto = &crypto.Crypto{
		Storage: cryptoBackend,
		Config: crypto.CryptoConfig{
			Keysize: 2048,
		},
	}
	if err != nil {
		panic(err)
	}
	return &registry
}

type testContext struct {
	registry *Registry
	repo     *test.TestRepo
}

func (cxt *testContext) empty() {
	cxt.repo.Cleanup()
	os.MkdirAll(filepath.Join(cxt.repo.Directory, "keys"), os.ModePerm)
	os.MkdirAll(filepath.Join(cxt.repo.Directory, "events"), os.ModePerm)
}

func (cxt *testContext) close() {
	defer cxt.registry.Shutdown()
	defer cxt.repo.Cleanup()
}

func createTestContext(t *testing.T) testContext {
	repo, err := test.NewTestRepo(t.Name())
	if err != nil {
		panic(err)
	}
	context := testContext{
		registry: createRegistry(repo),
		repo:     repo,
	}
	return context
}
