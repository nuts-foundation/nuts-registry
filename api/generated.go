// Package api provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"io"
	"io/ioutil"
	"net/http"
	"strings"
)

// Endpoint defines model for Endpoint.
type Endpoint struct {
	URL          string     `json:"URL"`
	EndpointType string     `json:"endpointType"`
	Identifier   Identifier `json:"identifier"`
	Status       string     `json:"status"`
	Version      string     `json:"version"`
}

// EndpointOrganization defines model for EndpointOrganization.
type EndpointOrganization struct {
	Endpoint     Identifier `json:"endpoint"`
	Organization Identifier `json:"organization"`
	Status       string     `json:"status"`
}

// Identifier defines model for Identifier.
type Identifier string

// Organization defines model for Organization.
type Organization struct {
	Endpoints  *[]Endpoint `json:"endpoints,omitempty"`
	Identifier Identifier  `json:"identifier"`
	Name       string      `json:"name"`
	PublicKey  *string     `json:"publicKey,omitempty"`
}

// EndpointsByOrganisationIdParams defines parameters for EndpointsByOrganisationId.
type EndpointsByOrganisationIdParams struct {
	OrgIds []string `json:"orgIds"`
	Type   *string  `json:"type,omitempty"`
	Strict *bool    `json:"strict,omitempty"`
}

// SearchOrganizationsParams defines parameters for SearchOrganizations.
type SearchOrganizationsParams struct {
	Query string `json:"query"`
}

// registerOrganizationJSONBody defines parameters for RegisterOrganization.
type registerOrganizationJSONBody Organization

// RegisterOrganizationRequestBody defines body for RegisterOrganization for application/json ContentType.
type RegisterOrganizationJSONRequestBody registerOrganizationJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(req *http.Request, ctx context.Context) error

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example.
	Server string

	// HTTP client with any customized settings, such as certificate chains.
	Client http.Client

	// A callback for modifying requests which are generated before sending over
	// the network.
	RequestEditor RequestEditorFn
}

// The interface specification for the client above.
type ClientInterface interface {
	// EndpointsByOrganisationId request
	EndpointsByOrganisationId(ctx context.Context, params *EndpointsByOrganisationIdParams) (*http.Response, error)

	// DeregisterOrganization request
	DeregisterOrganization(ctx context.Context, id string) (*http.Response, error)

	// OrganizationById request
	OrganizationById(ctx context.Context, id string) (*http.Response, error)

	// SearchOrganizations request
	SearchOrganizations(ctx context.Context, params *SearchOrganizationsParams) (*http.Response, error)

	// RegisterOrganization request  with any body
	RegisterOrganizationWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	RegisterOrganization(ctx context.Context, body RegisterOrganizationJSONRequestBody) (*http.Response, error)
}

func (c *Client) EndpointsByOrganisationId(ctx context.Context, params *EndpointsByOrganisationIdParams) (*http.Response, error) {
	req, err := NewEndpointsByOrganisationIdRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DeregisterOrganization(ctx context.Context, id string) (*http.Response, error) {
	req, err := NewDeregisterOrganizationRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) OrganizationById(ctx context.Context, id string) (*http.Response, error) {
	req, err := NewOrganizationByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) SearchOrganizations(ctx context.Context, params *SearchOrganizationsParams) (*http.Response, error) {
	req, err := NewSearchOrganizationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterOrganizationWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewRegisterOrganizationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterOrganization(ctx context.Context, body RegisterOrganizationJSONRequestBody) (*http.Response, error) {
	req, err := NewRegisterOrganizationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

// NewEndpointsByOrganisationIdRequest generates requests for EndpointsByOrganisationId
func NewEndpointsByOrganisationIdRequest(server string, params *EndpointsByOrganisationIdParams) (*http.Request, error) {
	var err error

	queryUrl := fmt.Sprintf("%s/api/endpoints", server)

	var queryStrings []string

	var queryParam0 string

	queryParam0, err = runtime.StyleParam("form", true, "orgIds", params.OrgIds)
	if err != nil {
		return nil, err
	}

	queryStrings = append(queryStrings, queryParam0)

	var queryParam1 string
	if params.Type != nil {

		queryParam1, err = runtime.StyleParam("form", true, "type", *params.Type)
		if err != nil {
			return nil, err
		}

		queryStrings = append(queryStrings, queryParam1)
	}

	var queryParam2 string
	if params.Strict != nil {

		queryParam2, err = runtime.StyleParam("form", true, "strict", *params.Strict)
		if err != nil {
			return nil, err
		}

		queryStrings = append(queryStrings, queryParam2)
	}

	if len(queryStrings) != 0 {
		queryUrl += "?" + strings.Join(queryStrings, "&")
	}

	req, err := http.NewRequest("GET", queryUrl, nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeregisterOrganizationRequest generates requests for DeregisterOrganization
func NewDeregisterOrganizationRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl := fmt.Sprintf("%s/api/organization/%s", server, pathParam0)

	req, err := http.NewRequest("DELETE", queryUrl, nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrganizationByIdRequest generates requests for OrganizationById
func NewOrganizationByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl := fmt.Sprintf("%s/api/organization/%s", server, pathParam0)

	req, err := http.NewRequest("GET", queryUrl, nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchOrganizationsRequest generates requests for SearchOrganizations
func NewSearchOrganizationsRequest(server string, params *SearchOrganizationsParams) (*http.Request, error) {
	var err error

	queryUrl := fmt.Sprintf("%s/api/organizations", server)

	var queryStrings []string

	var queryParam0 string

	queryParam0, err = runtime.StyleParam("form", true, "query", params.Query)
	if err != nil {
		return nil, err
	}

	queryStrings = append(queryStrings, queryParam0)

	if len(queryStrings) != 0 {
		queryUrl += "?" + strings.Join(queryStrings, "&")
	}

	req, err := http.NewRequest("GET", queryUrl, nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRegisterOrganizationRequest calls the generic RegisterOrganization builder with application/json body
func NewRegisterOrganizationRequest(server string, body RegisterOrganizationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRegisterOrganizationRequestWithBody(server, "application/json", bodyReader)
}

// NewRegisterOrganizationRequestWithBody generates requests for RegisterOrganization with any type of body
func NewRegisterOrganizationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl := fmt.Sprintf("%s/api/organizations", server)

	req, err := http.NewRequest("POST", queryUrl, body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses returns a ClientWithResponses with a default Client:
func NewClientWithResponses(server string) *ClientWithResponses {
	return &ClientWithResponses{
		ClientInterface: &Client{
			Client: http.Client{},
			Server: server,
		},
	}
}

// NewClientWithResponsesAndRequestEditorFunc takes in a RequestEditorFn callback function and returns a ClientWithResponses with a default Client:
func NewClientWithResponsesAndRequestEditorFunc(server string, reqEditorFn RequestEditorFn) *ClientWithResponses {
	return &ClientWithResponses{
		ClientInterface: &Client{
			Client:        http.Client{},
			Server:        server,
			RequestEditor: reqEditorFn,
		},
	}
}

type endpointsByOrganisationIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r endpointsByOrganisationIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r endpointsByOrganisationIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type deregisterOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r deregisterOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r deregisterOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type organizationByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r organizationByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r organizationByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type searchOrganizationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r searchOrganizationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r searchOrganizationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type registerOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r registerOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r registerOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// EndpointsByOrganisationIdWithResponse request returning *EndpointsByOrganisationIdResponse
func (c *ClientWithResponses) EndpointsByOrganisationIdWithResponse(ctx context.Context, params *EndpointsByOrganisationIdParams) (*endpointsByOrganisationIdResponse, error) {
	rsp, err := c.EndpointsByOrganisationId(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseendpointsByOrganisationIdResponse(rsp)
}

// DeregisterOrganizationWithResponse request returning *DeregisterOrganizationResponse
func (c *ClientWithResponses) DeregisterOrganizationWithResponse(ctx context.Context, id string) (*deregisterOrganizationResponse, error) {
	rsp, err := c.DeregisterOrganization(ctx, id)
	if err != nil {
		return nil, err
	}
	return ParsederegisterOrganizationResponse(rsp)
}

// OrganizationByIdWithResponse request returning *OrganizationByIdResponse
func (c *ClientWithResponses) OrganizationByIdWithResponse(ctx context.Context, id string) (*organizationByIdResponse, error) {
	rsp, err := c.OrganizationById(ctx, id)
	if err != nil {
		return nil, err
	}
	return ParseorganizationByIdResponse(rsp)
}

// SearchOrganizationsWithResponse request returning *SearchOrganizationsResponse
func (c *ClientWithResponses) SearchOrganizationsWithResponse(ctx context.Context, params *SearchOrganizationsParams) (*searchOrganizationsResponse, error) {
	rsp, err := c.SearchOrganizations(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParsesearchOrganizationsResponse(rsp)
}

// RegisterOrganizationWithBodyWithResponse request with arbitrary body returning *RegisterOrganizationResponse
func (c *ClientWithResponses) RegisterOrganizationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*registerOrganizationResponse, error) {
	rsp, err := c.RegisterOrganizationWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseregisterOrganizationResponse(rsp)
}

func (c *ClientWithResponses) RegisterOrganizationWithResponse(ctx context.Context, body RegisterOrganizationJSONRequestBody) (*registerOrganizationResponse, error) {
	rsp, err := c.RegisterOrganization(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseregisterOrganizationResponse(rsp)
}

// ParseendpointsByOrganisationIdResponse parses an HTTP response from a EndpointsByOrganisationIdWithResponse call
func ParseendpointsByOrganisationIdResponse(rsp *http.Response) (*endpointsByOrganisationIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &endpointsByOrganisationIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParsederegisterOrganizationResponse parses an HTTP response from a DeregisterOrganizationWithResponse call
func ParsederegisterOrganizationResponse(rsp *http.Response) (*deregisterOrganizationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &deregisterOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParseorganizationByIdResponse parses an HTTP response from a OrganizationByIdWithResponse call
func ParseorganizationByIdResponse(rsp *http.Response) (*organizationByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &organizationByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParsesearchOrganizationsResponse parses an HTTP response from a SearchOrganizationsWithResponse call
func ParsesearchOrganizationsResponse(rsp *http.Response) (*searchOrganizationsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &searchOrganizationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParseregisterOrganizationResponse parses an HTTP response from a RegisterOrganizationWithResponse call
func ParseregisterOrganizationResponse(rsp *http.Response) (*registerOrganizationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &registerOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Find endpoints based on organisation identifiers and type of endpoint (optional)// (GET /api/endpoints)
	EndpointsByOrganisationId(ctx echo.Context, params EndpointsByOrganisationIdParams) error
	// Remove organization by id// (DELETE /api/organization/{id})
	DeregisterOrganization(ctx echo.Context, id string) error
	// Get organization by id// (GET /api/organization/{id})
	OrganizationById(ctx echo.Context, id string) error
	// Search for organizations// (GET /api/organizations)
	SearchOrganizations(ctx echo.Context, params SearchOrganizationsParams) error
	// Add an organization to the registry// (POST /api/organizations)
	RegisterOrganization(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// EndpointsByOrganisationId converts echo context to params.
func (w *ServerInterfaceWrapper) EndpointsByOrganisationId(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params EndpointsByOrganisationIdParams
	// ------------- Required query parameter "orgIds" -------------
	if paramValue := ctx.QueryParam("orgIds"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument orgIds is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "orgIds", ctx.QueryParams(), &params.OrgIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter orgIds: %s", err))
	}

	// ------------- Optional query parameter "type" -------------
	if paramValue := ctx.QueryParam("type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "strict" -------------
	if paramValue := ctx.QueryParam("strict"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "strict", ctx.QueryParams(), &params.Strict)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter strict: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.EndpointsByOrganisationId(ctx, params)
	return err
}

// DeregisterOrganization converts echo context to params.
func (w *ServerInterfaceWrapper) DeregisterOrganization(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeregisterOrganization(ctx, id)
	return err
}

// OrganizationById converts echo context to params.
func (w *ServerInterfaceWrapper) OrganizationById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.OrganizationById(ctx, id)
	return err
}

// SearchOrganizations converts echo context to params.
func (w *ServerInterfaceWrapper) SearchOrganizations(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchOrganizationsParams
	// ------------- Required query parameter "query" -------------
	if paramValue := ctx.QueryParam("query"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument query is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "query", ctx.QueryParams(), &params.Query)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter query: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchOrganizations(ctx, params)
	return err
}

// RegisterOrganization converts echo context to params.
func (w *ServerInterfaceWrapper) RegisterOrganization(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RegisterOrganization(ctx)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router runtime.EchoRouter, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/api/endpoints", wrapper.EndpointsByOrganisationId)
	router.DELETE("/api/organization/:id", wrapper.DeregisterOrganization)
	router.GET("/api/organization/:id", wrapper.OrganizationById)
	router.GET("/api/organizations", wrapper.SearchOrganizations)
	router.POST("/api/organizations", wrapper.RegisterOrganization)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
